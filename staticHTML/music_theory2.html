<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Theory Module - Version 2 (Percentage-based Piano Width)</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap">
    <link rel="stylesheet" href="music_theory2.css">
</head>
<body>
    <div class="container">
        <div id="start-screen" class="screen active">
            <div class="header">
                <h1>Music Theory Training</h1>
            </div>
            <p>Test and improve your understanding of musical concepts through interactive challenges.</p>
            <p>You'll be presented with a series of musical elements to identify, including:</p>
            <ul>
                <li>Scales (Major, Minor, Pentatonic, etc.)</li>
                <li>Intervals (Perfect Fifth, Major Third, etc.)</li>
                <li>Chords (Major, Minor, Diminished, etc.)</li>
            </ul>
            <p>Use the piano keyboard or listen to the audio to help identify each element.</p>
            <p class="text-center"><strong>Version 2:</strong> This version uses percentage-based piano width for better responsiveness.</p>
            <button id="start-button" class="button">Start Training</button>
        </div>

        <div id="game-screen" class="screen">
            <div class="header">
                <h1>Music Theory Challenge</h1>
            </div>
            <div class="stats-container">
                <div class="stat">
                    <div class="stat-label">Level</div>
                    <div id="level" class="stat-value">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Score</div>
                    <div id="score" class="stat-value">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Streak</div>
                    <div id="streak" class="stat-value">0</div>
                </div>
            </div>
            <div class="challenge-container">
                <div id="challenge-message" class="challenge-message">
                    Identify the scale being played
                </div>
                <div class="toggle-buttons">
                    <button id="toggle-piano" class="toggle-button active">Piano</button>
                    <button id="toggle-waveform" class="toggle-button">Waveform</button>
                    <button id="toggle-circle" class="toggle-button">Circle of Fifths</button>
                </div>
                <div id="visualization-area">
                    <div id="piano-container"></div>
                    <div id="waveform-display" class="hidden"></div>
                    <div id="circle-of-fifths" class="hidden"></div>
                </div>
                <button id="play-button" class="button mb-10">Play Again</button>
                <div id="options-container" class="options-container">
                    <!-- Options will be dynamically inserted here -->
                </div>
                <button id="submit-button" class="button">Submit Answer</button>
            </div>
        </div>

        <div id="feedback-screen" class="screen">
            <div class="header">
                <h1>Feedback</h1>
            </div>
            <div class="feedback-container">
                <div id="feedback-message" class="feedback-message"></div>
                <div id="correct-answer" class="correct-answer"></div>
                <button id="next-button" class="button">Next Challenge</button>
            </div>
        </div>

        <div id="results-screen" class="screen">
            <div class="header">
                <h1>Training Results</h1>
            </div>
            <div class="results-container">
                <div class="final-score">
                    Score: <span id="final-score">0</span>
                </div>
                <div class="stats-summary">
                    <div class="stat">
                        <div class="stat-label">Best Streak</div>
                        <div id="best-streak" class="stat-value">0</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Max Level</div>
                        <div id="max-level" class="stat-value">1</div>
                    </div>
                </div>
                <div id="category-stats" class="category-stats">
                    <!-- Category stats will be inserted here -->
                </div>
                <button id="restart-button" class="button">Train Again</button>
            </div>
        </div>
    </div>

    <script>
        // Web Audio API Function stubs for note playing
        function playNote(midiNote, startTime, duration) {
            if (!audioContext) {
                try {
                    // Create audio context on user interaction
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.connect(audioContext.destination);
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser", e);
                    return;
                }
            }

            const noteFreq = 440 * Math.pow(2, (midiNote - 69) / 12);
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.value = noteFreq;
            
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(0.5, startTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
            
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);
            
            oscillator.start(startTime);
            oscillator.stop(startTime + duration);
        }

        // Stub functions for implementation
        function startGame() {
            screens.start.classList.remove('active');
            screens.game.classList.add('active');
            gameState.level = 1;
            gameState.score = 0;
            gameState.streak = 0;
            gameState.challengeCount = 0;
            updateStats();
            generateChallenge();
        }

        function updateStats() {
            elements.level.textContent = gameState.level;
            elements.score.textContent = gameState.score;
            elements.streak.textContent = gameState.streak;
        }

        function generateChallenge() {
            const difficulty = difficulties[gameState.level];
            const challengeType = difficulty.types[Math.floor(Math.random() * difficulty.types.length)];
            let elements = [];
            
            if (challengeType === 'scales') {
                elements = Object.keys(musicData.scales).filter(scale => 
                    difficulty.elements.includes(scale));
            } else if (challengeType === 'intervals') {
                elements = Object.keys(musicData.intervals).filter(interval => 
                    interval !== "Unison" && interval !== "Octave");
            } else if (challengeType === 'chords') {
                elements = Object.keys(musicData.chords);
            }
            
            const correctAnswer = elements[Math.floor(Math.random() * elements.length)];
            
            gameState.currentChallenge = {
                type: challengeType,
                name: correctAnswer,
                rootNote: 60 // Middle C
            };
            
            displayChallenge();
        }

        function displayChallenge() {
            // Update challenge message
            if (gameState.currentChallenge.type === 'scales') {
                elements.challengeMessage.textContent = 'Identify this scale:';
            } else if (gameState.currentChallenge.type === 'intervals') {
                elements.challengeMessage.textContent = 'Identify this interval:';
            } else if (gameState.currentChallenge.type === 'chords') {
                elements.challengeMessage.textContent = 'Identify this chord:';
            }
            
            // Generate options
            generateOptions();
            
            // Clear previous selections
            gameState.selectedOption = null;
            clearKeyHighlights();
            
            // Play the challenge
            playCurrentChallenge();
        }

        function generateOptions() {
            elements.optionsContainer.innerHTML = '';
            
            const difficulty = difficulties[gameState.level];
            let possibleOptions = [];
            
            if (gameState.currentChallenge.type === 'scales') {
                possibleOptions = Object.keys(musicData.scales).filter(scale => 
                    difficulty.elements.includes(scale));
            } else if (gameState.currentChallenge.type === 'intervals') {
                possibleOptions = Object.keys(musicData.intervals).filter(interval => 
                    interval !== "Unison" && interval !== "Octave");
            } else if (gameState.currentChallenge.type === 'chords') {
                possibleOptions = Object.keys(musicData.chords);
            }
            
            // Ensure correct answer is included
            let options = [gameState.currentChallenge.name];
            
            // Add random options until we reach the required number
            while (options.length < difficulty.options) {
                const randomOption = possibleOptions[Math.floor(Math.random() * possibleOptions.length)];
                if (!options.includes(randomOption)) {
                    options.push(randomOption);
                }
            }
            
            // Shuffle the options
            options = shuffleArray(options);
            
            // Create option elements
            options.forEach(option => {
                const optionEl = document.createElement('div');
                optionEl.className = 'option';
                optionEl.textContent = option;
                optionEl.addEventListener('click', () => {
                    // Deselect all options
                    document.querySelectorAll('.option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    // Select this option
                    optionEl.classList.add('selected');
                    gameState.selectedOption = option;
                });
                
                elements.optionsContainer.appendChild(optionEl);
            });
        }

        function playCurrentChallenge() {
            if (!gameState.currentChallenge) return;
            
            // Initialize audio context if needed
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    masterGainNode = audioContext.createGain();
                    masterGainNode.connect(audioContext.destination);
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser", e);
                    return;
                }
            }
            
            const rootNote = gameState.currentChallenge.rootNote;
            
            if (gameState.currentChallenge.type === 'scales') {
                const scaleIntervals = musicData.scales[gameState.currentChallenge.name];
                // Play scale ascending
                scaleIntervals.forEach((interval, index) => {
                    const note = rootNote + interval;
                    playNote(note, audioContext.currentTime + index * 0.5, 0.4);
                    
                    // Highlight key
                    setTimeout(() => {
                        highlightKey(note);
                        setTimeout(() => {
                            unhighlightKey(note);
                        }, 400);
                    }, index * 500);
                });
            } else if (gameState.currentChallenge.type === 'intervals') {
                const interval = musicData.intervals[gameState.currentChallenge.name];
                // Play root note, then interval
                playNote(rootNote, audioContext.currentTime, 0.4);
                playNote(rootNote + interval, audioContext.currentTime + 0.6, 0.4);
                
                // Highlight keys
                highlightKey(rootNote);
                setTimeout(() => {
                    unhighlightKey(rootNote);
                }, 400);
                
                setTimeout(() => {
                    highlightKey(rootNote + interval);
                    setTimeout(() => {
                        unhighlightKey(rootNote + interval);
                    }, 400);
                }, 600);
            } else if (gameState.currentChallenge.type === 'chords') {
                const chordIntervals = musicData.chords[gameState.currentChallenge.name];
                // Play chord tones simultaneously
                chordIntervals.forEach(interval => {
                    const note = rootNote + interval;
                    playNote(note, audioContext.currentTime, 0.8);
                    
                    // Highlight keys
                    highlightKey(note);
                    setTimeout(() => {
                        unhighlightKey(note);
                    }, 800);
                });
            }
        }

        function submitAnswer() {
            if (!gameState.selectedOption) {
                alert('Please select an answer');
                return;
            }
            
            const isCorrect = gameState.selectedOption === gameState.currentChallenge.name;
            
            // Update stats
            if (isCorrect) {
                gameState.score += 10 * gameState.level;
                gameState.streak++;
                if (gameState.streak > gameState.bestStreak) {
                    gameState.bestStreak = gameState.streak;
                }
            } else {
                gameState.streak = 0;
            }
            
            // Update category stats
            if (!gameState.categoryStats[gameState.currentChallenge.type]) {
                gameState.categoryStats[gameState.currentChallenge.type] = { correct: 0, total: 0 };
            }
            
            gameState.categoryStats[gameState.currentChallenge.type].total++;
            if (isCorrect) {
                gameState.categoryStats[gameState.currentChallenge.type].correct++;
            }
            
            // Show feedback
            showFeedback(isCorrect);
        }

        function showFeedback(isCorrect) {
            screens.game.classList.remove('active');
            screens.feedback.classList.add('active');
            
            if (isCorrect) {
                elements.feedbackMessage.textContent = 'Correct!';
                elements.feedbackMessage.className = 'feedback-message correct';
                elements.correctAnswer.textContent = '';
            } else {
                elements.feedbackMessage.textContent = 'Incorrect';
                elements.feedbackMessage.className = 'feedback-message incorrect';
                elements.correctAnswer.textContent = 
                    `The correct answer was: ${gameState.currentChallenge.name}`;
            }
        }

        function nextChallenge() {
            screens.feedback.classList.remove('active');
            screens.game.classList.add('active');
            
            // Update challenge count
            gameState.challengeCount++;
            
            // Check if level should increase
            if (gameState.streak > 0 && gameState.streak % 3 === 0 && gameState.level < 5) {
                gameState.level++;
            }
            
            // Check if game is over
            if (gameState.challengeCount >= gameState.totalChallenges) {
                showResults();
                return;
            }
            
            // Update display
            updateStats();
            
            // Generate new challenge
            generateChallenge();
        }

        function showResults() {
            screens.game.classList.remove('active');
            screens.results.classList.add('active');
            
            elements.finalScore.textContent = gameState.score;
            elements.bestStreak.textContent = gameState.bestStreak;
            elements.maxLevel.textContent = gameState.level;
            
            // Display category stats
            elements.categoryStats.innerHTML = '';
            
            for (const [category, stats] of Object.entries(gameState.categoryStats)) {
                if (stats.total > 0) {
                    const accuracy = Math.round((stats.correct / stats.total) * 100);
                    
                    const categoryEl = document.createElement('div');
                    categoryEl.className = 'category-stat';
                    
                    const nameEl = document.createElement('div');
                    nameEl.className = 'category-name';
                    nameEl.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                    
                    const accuracyEl = document.createElement('div');
                    accuracyEl.textContent = `Accuracy: ${accuracy}%`;
                    
                    const countEl = document.createElement('div');
                    countEl.textContent = `${stats.correct} / ${stats.total} correct`;
                    
                    categoryEl.appendChild(nameEl);
                    categoryEl.appendChild(accuracyEl);
                    categoryEl.appendChild(countEl);
                    
                    elements.categoryStats.appendChild(categoryEl);
                }
            }
        }

        function restartGame() {
            screens.results.classList.remove('active');
            screens.start.classList.add('active');
        }
    </script>

    <script src="music_theory2.js"></script>
</body>
</html> 